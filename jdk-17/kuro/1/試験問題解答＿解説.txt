問題１−１　A　C　E

問題１−２	B
packageの宣言文はjavaプログラムの1行目に記述しなければならないため。
package文、import文、class文の順に記述する

問題１−３	B　C
間違い

正解はA　C

原因　java.langパッケージの理解がたりなかった。
サブパッケージに関する理解がたりなかった。

問題１−４　C
正解

問題１−５　A　B　C
間違い

正解は　A　B　E
原因　エントリーポイントがわからなかった

問題１−６　B
正解

問題１−７　B　C
正解

問題１−８　C
間違い

正解は　B
原因　エスケープに対する理解が足りなかった。
"a "b　の際に出力される文字列が a b となることを見落としていた

間違えた問題 1-1 1-3 1-5 1-8

-------------------------------------------------------------------------
問題　２−１ C
booleanの型がboolとなっているため

正解

問題　２−２ D
Aは１０進数　B E は８進数 Cは16進数
消去法でD

間違い　正解はE
キーワード　接頭辞
８進数であれば先頭に０をつける　	例　０７７
１６進数であれば先頭に０ｘを付ける	例	０ｘ
２進数であれば先頭に０ｂを付ける	例	０ｂ

原因　８進数は０〜７の数字を扱うという理解が足りなかった

問題　２ー３　B　C　G　H　I
文法として間違っているため

間違い

正解は　Ｃ　Ｄ　Ｅ　Ｆ　Ｉ
アンダースコアを使った数値表記はJava SE 7から導入
使用する際のルール

リテラルの先頭と末尾には記述できない
記号の前後には記述できない

小数点を表す.の見落とし

リテラルの戦闘と末尾には記述できない
記号の前後には記述できない
利用できる記号は
小数点を表すドット「.」、
long型やfloat型リテラルを表す「L」「F」、
２進数を表す「０ｂ」
１６進数を表す「０ｘ」

問題　２−４　D
間違い

char String型の初期値はnullである
Aは””で囲っているため間違い　→　理解はあっている
実行する際はコンパイルエラーが発生する

Bは１文字の扱いであるchar型へ３文字入れているため間違い　→　理解があっている

Cは整数値リテラルを入れようとしているためコンパイルエラー　→　この理解が間違い
数値として０〜６５５３５までの数値を代入できる。
負の値を代入するとコンパイルエラー
Unicodeについての認識がなかった

char型はプリミティブ型（基本データ型）であり参照型ではないためnullの代入はできない



問題　２−５　C　D
間違い　D、E
識別子を付ける際のルール

・予約語を識別子として使うことはできない
・使える記号は、アンダースコア「_」と通貨記号$のみ
・数字から始めてはいけない（２文字目いこうであれば使用可）

試験対策として抑えることはアンダースコアと通貨記号が使用できる
数字から始めてはいけないの２点を抑えておく

中カッコ｛｝　ドット「.」は使用できない

問題　２−６　C
分からない　varに関する問題

間違い　正解はE
varは型推論を行うため、右辺から変数のデータ型を推論しそのデータ型に置き換える機能である
初期化、nullはコンパイルエラーとなる

ローカル変数の型推論は、リテラルだけでなく、メソッドの戻り値を受け取ることにも使える。
メソッドの定義から戻り値の型が判別できるため

ダイヤモンド演算子による型推論を行う

問題　２−７　C
正解
varによる型推論はローカル変数の宣言にしか使えない
フィールドには宣言できない

問題　２−８　A
正解

問題　２−９　A　B
正解

問題　２−１０　Ｃ
不正解

Stringオブジェクトが不変なオブジェクトであることを理解するための問題
オブジェクトは何らかのデータを持っている
変更できるオブジェクトを 	mutable(可変)なオブジェクト
変更できないオブジェクトを	immutabale(不可変)なオブジェクト

immutableなオブジェクトの定義
すべてのフィールドをprivateで修飾する
オブジェクト内部の状態を変更可能なメソッドを提供しない（setterメソッドを提供しない）
クラスをfinalで宣言し、メソッドがオーバーライドされないことを保証する（サブクラスからの変更を防ぐ）
内部に可変オブジェクトを保持している場合、そのオブジェクトを外部に提供しない（getterメソッドなど）

public final class Sample {
	private final String name;
	public Sample(String name) {
		this.name = name;
	}
	public void greet() {
		System.out.println("hello," + name);
	}
}

java.lang.Stringクラス
java.io.Fileクラスのインスタンスが該当する

Stringはimmutableなオブジェクトであるため、文字列を変更するには新しくインスタンスを作らなければならない
replaceAllメソッドをはじめとするStringクラスのメソッドの挙動

問題　２−１１　Ｂ
不正解
charAtのメソッドがわからない

正解　F（実行時エラー）

インスタンスが保持している文字列から、引数で指定された位置にある１文字だけを抜き出して戻す
0 1 2 3 4
a b c d e
0文字から探索開始

6番目の文字は存在しないためjava.lang.String IndexOutOfBoundsExceptionのエラー発生

問題　２−１２　Ｂ
不正解
indexOfの働きはわからないが、検索だったと思うので１が表示されると思う　→　理解はあっている

正解　E
探索結果が存在すれば結果を返すが
設問が abcde の５文字に対して abcdef の６文字を探索しているため、-1が返る

indexOf("c"); であれば2を
存在しなければ-1を返す

問題　２−１３　A
不正解
substringの働きがわからない

正解　D
引数で渡された範囲内の文字を抽出する（初めの引数のみの場合は開始位置以降のすべての文字を抽出する）

問題　２−１４　A
不正解
replaceの働きがわからない

正解はC
replaceメソッドは文字列を置き換えるメソッド
・先頭の２文字「aa」が「b」に置き換わり、「baa」という文字列が戻される
・置き換え後の文字列「baa」のうち、次に現れる「aa」が「bに置き換わる」
結果は「bb」という文字列が戻される

replaceメソッドは、第１引数に指定した文字列があれば、順番にすべて置き換えする。
replaceメソッドの引数は、char型かCharSequence型のうち、どちらか片方しか受け取らない

問題　２−１５　C
不正解

正解は F
lengthでabcdeの文字数を取得すると、結果は5
charAt(5)の状態
0から探索開始のcharAt()では０〜４という扱いになり、java.lang.StringIndexOutOfBoundsExceptionをスローする

問題　２−１６　F
不正解
substring.startsWith　どちらもわからない

正解は　A
startsWithは文字数が引数で指定された文字で始まるかどうかを調べるメソッド
結果は真偽値で返される

String str = "abc";
System.out.println(str.startsWith("a"));
⇒ true

endWithはその逆

問題　２−１７　B
不正解
appendは見たことある

正解は　A
concatメソッドは引数で渡された文字列に新しい文字列を連結する
Hello, Java!とあるため、concatメソッドで文字を繋ぐ必要がある
(appendはStringBuilderのメソッド)

問題　２−１８　C
正解
文字列の結合に対する問題

問題　２−１９　A
不正解

正解は B
+= 演算子と文字列の連結に関する問題
問題文ではnullの連結をおこなっているため
nullnullと表示される

問題　２−２０　B
不正解
StringBuilderに対する問題
わからない

正解は　D
StringBuilderは可変なオブジェクトである
内部構造はデフォルトで１６文字分のバッファを持っている
文字列を引数に渡す場合、「文字列の長さ　＋　１６文字分」のバッファを持っている

問題　２−２１　D
正解
appendメソッドは後ろに文字列を追加する
reverseメソッドは文字列を反転する
edcba の dc の部分をaに置き換え
eabaとなる

問題　２−２２　A
正解
String同様indexOfは文字列の「開始位置」を戻す

間違えた問題 1-1 1-3 1-5 1-8
間違えた問題 ２−２ ２ー３　２−４　２−５　２−６　２−１０　２−１１　２−１２　２−１０　２−１１　２−１２　２−１３　２−１４　２−１５　２−１６　２−１７　２−１９　２−２０
--------------------------------------------------------

問題１−１ A C E
不正解

A C D

問題１−３ A C

問題１−５ A B E

問題１−８ B


問題２−２　E

問題２−３　C　D　E　F　I
EFI _は記号の前後には記述できないため

２−４　C
char型は数値を代入することもできるため

２−５　D　E

２−６　E

２−１０　A

２−１１　F

２−１２　E

２−１３　D

２−１４　C

２−１５　F

２−１６　A

２−１７　A

２−１９　B

２−２０　D

-------------------------------------------------------------

練習１−１　A　C　E
不正解　A　C　D

練習１−２　B
正解

練習１−３　A　C
正解

練習１−４　C
正解

練習１−５　A　B　E
正解

練習１−６　B
正解

練習１−７　B　C
正解

練習１−８　B
正解

import java.lang.String;	//	省略可能
import java.lang.Integer;	//	省略可能
import java.math.BigDecimal;

public class Main {
	public static void main(String[] args) {
		String str = "100";
		int val = Integer.paraseInt(str);
		BigDecimal decimal = new BigDecimal(val);
		System.out.println(decimal.intValue());
	}
}
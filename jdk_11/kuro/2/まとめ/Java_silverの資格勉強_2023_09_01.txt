6章
6, 16,22,24,

1
クラスとインスタンスに関する問題

オブジェクト指向プログラミング
①クラスを定義する
②クラスからインスタンスを生成して、インスタンスが動作する

ソースファイルは単なるファイルのため、PCのメモリ上では動かない。	← クラス
JVMがソースファイルを読み込みメモリ上にコピーする。		← インスタンス

クラスファイルを読み込むことをロードという

設問のコード
a,b二つのインスタンスを生成し、bのnumの値を書き換えている。
aの値は変更がない
そのため、インスタンス生成時の10で初期化された状態。


2
複数のインスタンスを生成し、それぞれ異なる値を持たせた上で、変数がどのインスタンスへの参照を持っているのかといった点。
変数内の参照が、どのタイミングで変わったのかをしっかりと把握する。

5
staticなフィールドへのアクセスについて問う
「static領域」	staticで修飾されたフィールドやメソッドのこと
		インスタンスを生成しなくても使用できる

「ヒープ領域」	static以外の部分	newするたびにクラス定義に従ったインスタンスを生成する。
		インスタンスを生成しなければ使用できない

static領域とヒープ領域ではメンバが分離されるため、
staticなフィールドはインスタンスを作らなくても使える。

staticなフィールドへのアクセス
「クラス名.フィールド名」
Sample.num = 10;

インスタンスを生成し、その参照を使いアクセスする。
Sample s = new Sample();
s.num = 20;
↑コンパイル時に「クラス名.フィールド名」に書き換えられる。

Sample s = new Sample();
Sample.num = 20;

「クラス名.フィールド名」とインスタンスを生成、その参照にアクセスは同義であるため、同じ変数の値を変更し続けていることになる。

★staticなフィールドは「クラス名.フィールド名」
インスタンスの生成後であれば、「参照.フィールド名」のどちらでもアクセスできる。

6
staticなメンバのルールに関する問題

staticなメンバ（staticで修飾されたフィールドやメソッド）はインスタンスが作られるメモリとは異なる領域にある。

staticではないメソッドからは、staticなフィールドにアクセスできる
インスタンスを生成しなくても使用できるため。

staticなメソッドから、staticではないメソッドにはアクセスできない
インスタンスを生成しなくては使用できないため（存在しないものを呼び出そうとしている）

staticなメソッドから、staticなフィールドやメソッドは自由にアクセスできる。
staticなメソッド同士では、インスタンスの有無に関係なく扱える。

★staticなメソッドからは、staticなメンバ（staticで修飾されたフィールドやメソッド）にしかアクセスできない

7
メソッドの呼び出しについて

・同じインスタンスに定義されているメソッドの場合、メソッド名（引数）
・インスタンスに定義されているメソッドの場合、変数.メソッド名（引数）
・staticなメソッドの場合、クラス名.メソッド名（引数）

A メソッド名の後ろに()がないため、フィールドにアクセスする際の記述である
B 異なるインスタンスが持つメソッドでは

8
呼び出されるメソッドがインスタンスのメソッドなのか、staticなメソッドなのかを確認すること
呼び出し元のメソッドが、呼び出されるメソッドのシグニチャと一致しているか確認する

10
メソッドの構文
アクセス修飾子　戻り値の型 メソッド名（引数の型　引数名） {
	//	メソッド内の処理
}

11
メソッド「B」の戻り値を受け取りたいときAに変数を宣言し、代入式を記述する
int型を戻すsampleというメソッド

int result = sample();

22
staticで修飾されたクラス変数について
staticはインスタンスを生成しなくても使える変数のため、初期化子やコンストラクタで、
インスタンス生成前にクラス変数を初期化することができない。
初期化子もコンストラクタも、インスタンスを生成するタイミングでしか実行されないため。

static int num;
宣言された状態でnumの値はデフォルトの0のまま

インスタンスを生成した後であれば、初期化子、コンストラクタの順で実行されるため値が変更される。

24
コンストラクタはいくつかのルールがあるものの、メソッドの一種であるためオーバーロードすることが可能である。

オーバーロードされたコンストラクタから別のコンストラクタを呼び出すにはthisを使う。

thisの二つの使い方
オーバーロードされた別のコンストラクタを呼び出すときに使用するthis
インスタンスそのものを表す参照を入れる特別な変数として使う場合。
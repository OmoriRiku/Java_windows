7章

1 D
継承ではスーパークラスの特徴をサブクラスが引き継ぐことになる。

コンストラクタのChildとhelloメソッドで使用されているnameはChildに定義されていない
Parentクラスのフィールドにnameを指定することで、使用することができる。

public class Parent {
	String name;
}

public class Child extends Parent {
	// String name を引き継いでいる。
}

2 C
継承ではコンストラクタは引き継げないため

A, デフォルト修飾子では同じパッケージに属するクラスからのアクセスのみ
→ すべてのサブクラスからではない

B private修飾子では同じクラス（インナークラス）でなければアクセスできない
→ サブクラスで利用することはできない

D protected修飾子では同じクラスとサブクラスからアクセスできる
→ デフォルト修飾子の説明のため

3 A, E
A インタフェースは公開されることを前提としているため、publicで修飾されていなくても、publicで扱われる

4 A
インタフェースに処理を記述することはできないため
処理があるメソッドをインタフェースで使用するためにはdefault修飾子を使用する。

5 D
default修飾子で修飾されたメソッドはオーバーライドすることができる。
java.lang.Objectクラスに属するtoString()メソッドはオーバーライドすることができない。

6 E
スーパークラスのメソッドを呼び出すには
スーパークラスのクラス名.super.メソッド名（）
と記述する。

interface A
↑
interface B
↑
C				Main

メソッドをまたいでスーパークラスのメソッドを呼び出すことはできない。

★7
インタフェースAとBは異なるインタフェースである。
インタフェースの多重実現はできるが、testメソッドがオーバーロードされており、どちらを呼び出すのかプログラマーが明示しなければならない。
明示する際はオーバーライドしてA.super.メソッド名（）を記述する。
public void test() {
	A.super.test();
}
とすればコンパイルエラーもおきず実行もできる。

★8  A, C, D
抽象クラスはインタフェースとクラスの両方の特徴を持つ

インスタンスを生成することはできない
abstract class A {}
class Test {
	public static void main(String[] args) {
		new A();	//	コンパイルエラー
	}
}

抽象クラスから抽象クラスを継承することは可能である。

抽象メソッドは、すべてのサブクラスが実装しなければならない。
abstract class A {
	abstract void hello();
}

class B extends A {
	void hello() {
		System.out.println("hello");
	}
}

★9 A

★10 A

11 C
オーバーライドする際に使用するアクセス修飾子はもともとに定義されているアクセス修飾子より
制限を緩くしなければいけない

12 B
A a = new B();	A型のフィールドを扱う
A b = new B();	A型のフィールドを扱う
a.valとb.valの値はともにAのため、AAと表示
void printメソッドはフィールドの値を表示しているため、再度AA

13 C
Engnieer型はEmployee型のクラスを引き継いでいる。
Engnieer型はEmployee型を引き継ぐため、workメソッドを持っていることになる。
Engnieer型はWorker型のメソッドの実装を持っていると解釈される

14 A
Worker型のクラスにcreateメソッドはないため、コンパイルエラー
Employee型のクラスにworkメソッドは定義されているため、実行できる
Engnieer型のクラスにcreateメソッドは定義されているため、実行できる

15 F
クラスDは継承関係にないため、A型で扱うことができないため
Aはインタフェースであるため、インスタンスを生成することができない

16 F
クラスのダウンキャストに関する問題
キャスト演算子を使用してB型で利用すると明示する必要がある

17 B
変数AはA型でインスタンスを生成している。
A型とB型は継承関係があり、ダウンキャストをすることができる。
AのインスタンスにはBでオーバーライドされたメソッドを扱うことが出来ないため例外スロー

18 A D
A 自身のフィールドにアクセスする際はthis.フィールド名を使用する。
this.num = num;
D setNumメソッドでは渡された引数を自身のフィールドで初期化することができるため

★19 B
Parentクラスとchildクラスでは同じフィールドnameがある。
MainクラスではChild型でChild型のインスタンスを生成したのち、nameの値を変更している。
Child型のフィールドnameの値は変更される
Parent型のフィールドnameの値はnullのまま
継承関係にあり、Parentクラスのメソッドを呼び出すことができるため、呼び出し時はParentクラスのフィールドを呼び出しnullが表示される。

20 B
AとBの両方にコンストラクタがある場合、初めにスーパークラスのコンストラクタが呼び出される
Bクラスのコンストラクタに暗黙的にsuper()が記述されるため。

21 A
this()はオーバーライドされた自身のコンストラクタを呼び出す。
super()はスーパークラスのコンストラクタを呼び出す。
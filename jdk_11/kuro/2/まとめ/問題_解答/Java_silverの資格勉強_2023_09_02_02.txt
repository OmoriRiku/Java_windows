7章

1 D
継承ではスーパークラスの特徴をサブクラスが引き継ぐことになる。

コンストラクタのChildとhelloメソッドで使用されているnameはChildに定義されていない
Parentクラスのフィールドにnameを指定することで、使用することができる。

public class Parent {
	String name;
}

public class Child extends Parent {
	// String name を引き継いでいる。
}

2 C
継承ではコンストラクタは引き継げないため

A, デフォルト修飾子では同じパッケージに属するクラスからのアクセスのみ
→ すべてのサブクラスからではない

B private修飾子では同じクラス（インナークラス）でなければアクセスできない
→ サブクラスで利用することはできない

D protected修飾子では同じクラスとサブクラスからアクセスできる
→ デフォルト修飾子の説明のため

3 A, E
A インタフェースは公開されることを前提としているため、publicで修飾されていなくても、publicで扱われる

4 A
インタフェースに処理を記述することはできないため
処理があるメソッドをインタフェースで使用するためにはdefault修飾子を使用する。

5 D

6 E
スーパークラスのメソッドを呼び出すには
スーパークラスのクラス名.super.メソッド名（）
と記述する。

interface A
↑
interface B
↑
C				Main

メソッドをまたいでスーパークラスのメソッドを呼び出すことはできない。

★7


★8  A, C, D

★9 A

★10 A

11 C
オーバーライドする際に使用するアクセス修飾子はもともとに定義されているアクセス修飾子より
制限を緩くしなければいけない

12 B
A a = new B();	A型のフィールドを扱う
A b = new B();	A型のフィールドを扱う
a.valとb.valの値はともにAのため、AAと表示
void printメソッドはフィールドの値を表示しているため、再度AA

13 C

14 A
Worker型のインタフェースにcreateメソッドはないため、コンパイルエラー
Employee型のクラスにworkメソッドは定義されているため、実行できる
Engnieer型のクラスにcreateメソッドは定義されているため、実行できる

15 F
クラスDは継承関係にないため、A型で扱うことができないため
Aはインタフェースであるため、インスタンスを生成することができない

16 F
クラスのダウンキャストに関する問題
キャスト演算子を使用してB型で利用すると明示する必要がある

17 B

18 A D
A 自身のフィールドにアクセスする際はthis.フィールド名を使用する。
this.num = num;

D setNumメソッドでは渡された引数を自身のフィールドで初期化することができるため

★19 B

20 B
メソッドはメソッドの処理に従う

21 A